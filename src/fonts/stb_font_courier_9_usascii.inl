// Font generated by stb_font_inl_generator.c (4/1 bpp)
//
// Following instructions show how to use the only included font, whatever it is, in
// a generic way so you can replace it with any other font by changing the include.
// To use multiple fonts, replace STB_SOMEFONT_* below with STB_FONT_courier_9_usascii_*,
// and separately install each font. Note that the CREATE function call has a
// totally different name; it's just 'stb_font_courier_9_usascii'.
//
/* // Example usage:

static stb_fontchar fontdata[STB_SOMEFONT_NUM_CHARS];

static void init(void)
{
    // optionally replace both STB_SOMEFONT_BITMAP_HEIGHT with STB_SOMEFONT_BITMAP_HEIGHT_POW2
    static unsigned char fontpixels[STB_SOMEFONT_BITMAP_HEIGHT][STB_SOMEFONT_BITMAP_WIDTH];
    STB_SOMEFONT_CREATE(fontdata, fontpixels, STB_SOMEFONT_BITMAP_HEIGHT);
    ... create texture ...
    // for best results rendering 1:1 pixels texels, use nearest-neighbor sampling
    // if allowed to scale up, use bilerp
}

// This function positions characters on integer coordinates, and assumes 1:1 texels to pixels
// Appropriate if nearest-neighbor sampling is used
static void draw_string_integer(int x, int y, char *str) // draw with top-left point x,y
{
    ... use texture ...
    ... turn on alpha blending and gamma-correct alpha blending ...
    glBegin(GL_QUADS);
    while (*str) {
        int char_codepoint = *str++;
        stb_fontchar *cd = &fontdata[char_codepoint - STB_SOMEFONT_FIRST_CHAR];
        glTexCoord2f(cd->s0, cd->t0); glVertex2i(x + cd->x0, y + cd->y0);
        glTexCoord2f(cd->s1, cd->t0); glVertex2i(x + cd->x1, y + cd->y0);
        glTexCoord2f(cd->s1, cd->t1); glVertex2i(x + cd->x1, y + cd->y1);
        glTexCoord2f(cd->s0, cd->t1); glVertex2i(x + cd->x0, y + cd->y1);
        // if bilerping, in D3D9 you'll need a half-pixel offset here for 1:1 to behave correct
        x += cd->advance_int;
    }
    glEnd();
}

// This function positions characters on float coordinates, and doesn't require 1:1 texels to pixels
// Appropriate if bilinear filtering is used
static void draw_string_float(float x, float y, char *str) // draw with top-left point x,y
{
    ... use texture ...
    ... turn on alpha blending and gamma-correct alpha blending ...
    glBegin(GL_QUADS);
    while (*str) {
        int char_codepoint = *str++;
        stb_fontchar *cd = &fontdata[char_codepoint - STB_SOMEFONT_FIRST_CHAR];
        glTexCoord2f(cd->s0f, cd->t0f); glVertex2f(x + cd->x0f, y + cd->y0f);
        glTexCoord2f(cd->s1f, cd->t0f); glVertex2f(x + cd->x1f, y + cd->y0f);
        glTexCoord2f(cd->s1f, cd->t1f); glVertex2f(x + cd->x1f, y + cd->y1f);
        glTexCoord2f(cd->s0f, cd->t1f); glVertex2f(x + cd->x0f, y + cd->y1f);
        // if bilerping, in D3D9 you'll need a half-pixel offset here for 1:1 to behave correct
        x += cd->advance;
    }
    glEnd();
}
*/

#ifndef STB_FONTCHAR__TYPEDEF
#define STB_FONTCHAR__TYPEDEF
typedef struct
{
    // coordinates if using integer positioning
    float s0,t0,s1,t1;
    signed short x0,y0,x1,y1;
    int   advance_int;
    // coordinates if using floating positioning
    float s0f,t0f,s1f,t1f;
    float x0f,y0f,x1f,y1f;
    float advance;
} stb_fontchar;
#endif

#define STB_FONT_courier_9_usascii_BITMAP_WIDTH         128
#define STB_FONT_courier_9_usascii_BITMAP_HEIGHT         30
#define STB_FONT_courier_9_usascii_BITMAP_HEIGHT_POW2    32

#define STB_FONT_courier_9_usascii_FIRST_CHAR            32
#define STB_FONT_courier_9_usascii_NUM_CHARS             95

#define STB_FONT_courier_9_usascii_LINE_SPACING           4

static unsigned int stb__courier_9_usascii_pixels[]={
    0x04462800,0xa8406302,0x22170201,0x844c4131,0x98040a89,0x2a60ccc2,
    0x2a5300e1,0x54c22660,0x0e0aaa21,0x18619885,0x2131b983,0xa9862809,
    0x218c1851,0x0a9c4908,0x45143571,0x21c52831,0x42218442,0x261814a3,
    0x54155119,0x428c262a,0x4c288e12,0x13289860,0x1c31460c,0x18182231,
    0x5dc0998a,0x844098a1,0x0e6a3861,0x4448cc62,0x31982aa1,0x50e3510a,
    0x1a888c28,0x9a83818a,0x030a6a23,0x230a0943,0x30883022,0x41c429a8,
    0x88c428a1,0x831861bb,0x104c2a50,0x45511183,0x2180a061,0x4c533008,
    0x853531a9,0x7030e19a,0x1b98a033,0x86e6a218,0x8c506618,0x5282e618,
    0x2050cc28,0x40662172,0x000330a8,0x2ea20000,0x00131002,0x02209800,
    0x01800c00,0x00060544,0x00000000,0x00000000,0x00000cc0,0x00000000,
    0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
    0x05433300,0x20330554,0x2b88d4c0,0x86660ccc,0x202a61ab,0x4c6a61aa,
    0x31554151,0x20a8cc15,0x11a8d418,0x1a8d4355,0x11182a33,0x104c4426,
    0x09981986,0x10983946,0x31054501,0x50ca0c0a,0x8303130a,0x4628c432,
    0x8844608a,0x2219c430,0x214e2034,0x13066619,0x186ae318,0x25331540,
    0x2a20c0c1,0x51140e22,0x30c48853,0xa826e261,0x110c60a9,0x22050835,
    0x0cc04111,0x4a318aaa,0x0c0d44a1,0x30c2218c,0x20614d44,0x17333189,
    0x8a6a04cc,0x405438a9,0x8a622089,0x542a6e2a,0x260e229a,0x3351d541,
    0x15370a66,0x43350cd4,0x026a229a,0xab882e60,0x00b94c03,0x0ae249c4,
    0x0524a61c,0x00004001,0x20000800,0x00000aba,0x00000000,0x00000000,
    0x00000000,0x55300000,0x444c2a81,0x54c04141,0x986080aa,0x510554c2,
    0x8cc2a355,0x0a94c1a8,0x235506a2,0x41550528,0x11554c18,0x180cc355,
    0x83181983,0x182a6289,0x88544113,0x0c18c0c4,0x03054663,0x20a50666,
    0x0d5418c1,0x30630a31,0x5c0aa826,0x18c18c2a,0x20d4054c,0x40c00d41,
    0x261dc1ab,0x5c060899,0xb83004c3,0x2a60443a,0x30c1dc2a,0x2088c29c,
    0x065542ab,0x83053055,0x031621a8,0x8c098313,0x45430c12,0x06054d42,
    0x35011063,0x86180985,0x8555cc31,0x2700351b,0x1730150c,0x57510310,
    0x371199cc,0x2e2551b8,0x02a731aa,0xb9c46ea0,0x30206aa0,0x2ae21557,
    0x0005ce22,0x00000000,0x00000000,0x00000000,0x14400000,0x58e36006,
    0x44111110,0x5c433515,0x8100003b,0x41541309,0x4446aa1a,0x4661940a,
    0xa851330a,0x410a311a,0x54472a52,0x247190aa,0x00cccc45,0x00000022,
    0x83033183,0x14e28198,0x250c60a6,0xa862208b,0x9980aa19,0x42155511,
    0x00000020,0x2e620000,0x20c0dd41,0x0c619832,0x8c618c06,0x41710620,
    0x00000004,0x00000000,0x30719030,0x88663aa8,0x06ae2173,0x4538b871,
    0x032733ac,0x00000000,0x00000000,0x20dd4003,0x00557139,0x00000000,
    0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,
};

static signed short stb__courier_9_usascii_x[95]={ 0,1,1,0,0,0,0,1,2,1,0,0,1,0,
1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0, };
static signed short stb__courier_9_usascii_y[95]={ 6,1,1,0,0,1,1,1,1,1,1,1,4,3,
5,0,1,1,1,1,1,1,1,1,1,1,2,2,1,2,1,1,0,1,1,1,1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,7,0,2,1,2,1,2,1,2,1,0,
0,1,1,2,2,2,2,2,2,2,1,2,2,2,2,2,2,1,1,1,3, };
static unsigned short stb__courier_9_usascii_w[95]={ 0,2,3,5,4,5,4,2,2,2,3,5,2,5,
2,4,4,4,4,4,4,4,4,4,4,4,2,2,4,5,4,3,4,5,5,5,5,5,5,5,5,4,5,5,
5,5,5,4,5,5,5,5,5,5,5,5,5,5,4,2,3,2,4,6,3,5,5,5,5,5,5,5,5,5,
4,5,5,5,5,5,5,5,5,4,5,5,5,5,5,5,4,2,1,2,5, };
static unsigned short stb__courier_9_usascii_h[95]={ 0,6,3,7,7,6,6,3,7,7,3,5,4,1,
2,7,6,5,5,6,5,6,6,6,6,6,5,5,5,3,5,6,7,5,5,6,5,5,5,6,5,5,6,5,
5,5,5,6,5,6,5,6,5,6,5,5,5,5,5,7,7,7,3,2,3,5,6,5,6,5,5,6,5,6,
8,5,5,4,4,5,6,6,4,5,6,5,4,5,4,6,4,7,7,7,2, };
static unsigned short stb__courier_9_usascii_s[95]={ 51,91,81,6,20,17,23,85,25,28,71,
1,63,108,99,31,28,13,23,44,18,49,33,117,86,112,106,124,101,75,90,
13,39,72,66,1,54,48,121,38,30,25,60,13,7,1,118,75,106,54,115,
80,95,100,112,100,88,71,77,48,44,36,66,92,88,82,7,19,122,42,36,
106,60,94,1,84,109,46,28,94,63,57,34,66,69,78,40,7,57,51,52,
17,15,12,102, };
static unsigned short stb__courier_9_usascii_t[95]={ 8,1,22,1,1,10,10,22,1,1,22,
23,23,22,22,1,10,23,23,10,23,10,10,1,1,1,16,10,16,22,16,
10,1,16,16,10,17,17,16,10,17,17,10,17,17,17,10,1,10,10,16,
1,16,1,10,10,10,10,10,1,1,1,22,22,22,10,10,17,1,17,17,
1,17,1,1,16,16,23,23,10,1,1,23,10,1,16,23,23,23,1,23,
1,1,1,22, };
static unsigned short stb__courier_9_usascii_a[95]={ 76,76,76,76,76,76,76,76,
76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,
76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,
76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,
76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,
76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,76,
76,76,76,76,76,76,76, };

// Call this function with
//    font: NULL or array length
//    data: NULL or specified size
//    height: STB_FONT_courier_9_usascii_BITMAP_HEIGHT or STB_FONT_courier_9_usascii_BITMAP_HEIGHT_POW2
//    return value: spacing between lines
static void stb_font_courier_9_usascii(stb_fontchar font[STB_FONT_courier_9_usascii_NUM_CHARS],
                unsigned char data[STB_FONT_courier_9_usascii_BITMAP_HEIGHT][STB_FONT_courier_9_usascii_BITMAP_WIDTH],
                int height)
{
    int i,j;
    if (data != 0) {
        unsigned int *bits = stb__courier_9_usascii_pixels;
        unsigned int bitpack = *bits++, numbits = 32;
        for (i=0; i < STB_FONT_courier_9_usascii_BITMAP_WIDTH*height; ++i)
            data[0][i] = 0;  // zero entire bitmap
        for (j=1; j < STB_FONT_courier_9_usascii_BITMAP_HEIGHT-1; ++j) {
            for (i=1; i < STB_FONT_courier_9_usascii_BITMAP_WIDTH-1; ++i) {
                unsigned int value;
                if (numbits==0) bitpack = *bits++, numbits=32;
                value = bitpack & 1;
                bitpack >>= 1, --numbits;
                if (value) {
                    if (numbits < 3) bitpack = *bits++, numbits = 32;
                    data[j][i] = (bitpack & 7) * 0x20 + 0x1f;
                    bitpack >>= 3, numbits -= 3;
                } else {
                    data[j][i] = 0;
                }
            }
        }
    }

    // build font description
    if (font != 0) {
        float recip_width = 1.0f / STB_FONT_courier_9_usascii_BITMAP_WIDTH;
        float recip_height = 1.0f / height;
        for (i=0; i < STB_FONT_courier_9_usascii_NUM_CHARS; ++i) {
            // pad characters so they bilerp from empty space around each character
            font[i].s0 = (stb__courier_9_usascii_s[i]) * recip_width;
            font[i].t0 = (stb__courier_9_usascii_t[i]) * recip_height;
            font[i].s1 = (stb__courier_9_usascii_s[i] + stb__courier_9_usascii_w[i]) * recip_width;
            font[i].t1 = (stb__courier_9_usascii_t[i] + stb__courier_9_usascii_h[i]) * recip_height;
            font[i].x0 = stb__courier_9_usascii_x[i];
            font[i].y0 = stb__courier_9_usascii_y[i];
            font[i].x1 = stb__courier_9_usascii_x[i] + stb__courier_9_usascii_w[i];
            font[i].y1 = stb__courier_9_usascii_y[i] + stb__courier_9_usascii_h[i];
            font[i].advance_int = (stb__courier_9_usascii_a[i]+8)>>4;
            font[i].s0f = (stb__courier_9_usascii_s[i] - 0.5f) * recip_width;
            font[i].t0f = (stb__courier_9_usascii_t[i] - 0.5f) * recip_height;
            font[i].s1f = (stb__courier_9_usascii_s[i] + stb__courier_9_usascii_w[i] + 0.5f) * recip_width;
            font[i].t1f = (stb__courier_9_usascii_t[i] + stb__courier_9_usascii_h[i] + 0.5f) * recip_height;
            font[i].x0f = stb__courier_9_usascii_x[i] - 0.5f;
            font[i].y0f = stb__courier_9_usascii_y[i] - 0.5f;
            font[i].x1f = stb__courier_9_usascii_x[i] + stb__courier_9_usascii_w[i] + 0.5f;
            font[i].y1f = stb__courier_9_usascii_y[i] + stb__courier_9_usascii_h[i] + 0.5f;
            font[i].advance = stb__courier_9_usascii_a[i]/16.0f;
        }
    }
}

#ifndef STB_SOMEFONT_CREATE
#define STB_SOMEFONT_CREATE              stb_font_courier_9_usascii
#define STB_SOMEFONT_BITMAP_WIDTH        STB_FONT_courier_9_usascii_BITMAP_WIDTH
#define STB_SOMEFONT_BITMAP_HEIGHT       STB_FONT_courier_9_usascii_BITMAP_HEIGHT
#define STB_SOMEFONT_BITMAP_HEIGHT_POW2  STB_FONT_courier_9_usascii_BITMAP_HEIGHT_POW2
#define STB_SOMEFONT_FIRST_CHAR          STB_FONT_courier_9_usascii_FIRST_CHAR
#define STB_SOMEFONT_NUM_CHARS           STB_FONT_courier_9_usascii_NUM_CHARS
#define STB_SOMEFONT_LINE_SPACING        STB_FONT_courier_9_usascii_LINE_SPACING
#endif

